// Configuración de MathJax para renderizar ecuaciones
MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
        fontCache: 'global'
    }
};

function calculateDerivative() {
    const functionInput = document.getElementById('functionInput').value.trim();
    const outputDiv = document.getElementById('output');
    outputDiv.innerHTML = ''; // Limpiar resultados anteriores

    if (!functionInput) {
        outputDiv.innerHTML = '<p class="error-message">Por favor, introduce una función.</p>';
        return;
    }

    try {
        // Parsear la expresión usando Math.js
        const node = math.parse(functionInput);

        // Calcular la derivada final usando math.js (para el resultado y referencia)
        const derivativeNode = math.derivative(node, 'x');
        const finalDerivativeTex = derivativeNode.toTex();

        let stepsHtml = `<h2>Solución Detallada de $f'(x)$</h2>`;
        stepsHtml += `
            <div class="step">
                <h3>Paso 1: Escribir la definición formal de la derivada</h3>
                <p>Comenzamos con la definición fundamental de la derivada de una función $f(x)$:</p>
                <div class="math-formula">
                    $$f'(x) = \\lim_{h \\to 0} \\frac{f(x + h) - f(x)}{h}$$
                </div>
                <p>En nuestro caso, la función es $f(x) = ${node.toTex()}$.</p>
            </div>
        `;

        // --- Simulación de pasos para funciones polinómicas simples ---
        // Esta parte es la que intentará generar los pasos de forma más "manual"
        // para tipos de funciones específicos que se pueden manejar fácilmente.
        const funcString = functionInput.toLowerCase().replace(/\s/g, ''); // Normalizar la entrada

        // Intentamos detectar patrones simples para generar pasos
        let isPolynomialHandled = false;

        // Patron para a*x^n + b*x + c
        const polyMatch = funcString.match(/^((?:[+-]?\d*\*?)?x(?:\^\d+)?)?((?:[+-]?\d*\*?)?x)?((?:[+-]?\d+))?$/);

        if (polyMatch) {
            // Reconstruir los términos para un manejo más fácil
            let term1 = polyMatch[1] || ''; // x^n term
            let term2 = polyMatch[2] || ''; // x term
            let term3 = polyMatch[3] || ''; // constant term

            // Eliminar '+' inicial si viene de la concatenación
            if (term2.startsWith('+')) term2 = term2.substring(1);
            if (term3.startsWith('+')) term3 = term3.substring(1);

            // Preparar f(x+h) simbólicamente
            let fxPlusHNode;
            try {
                 // Convertir la entrada a un árbol de expresiones de math.js
                 let exprNode = math.parse(functionInput);
                 // Sustituir 'x' por 'x + h' simbólicamente
                 fxPlusHNode = math.substitute(exprNode, math.parse('x'), math.parse('x + h'));
            } catch (e) {
                // Si la sustitución falla, probablemente la función es muy compleja para este manejo simple.
                isPolynomialHandled = false;
            }


            if (fxPlusHNode) { // Solo proceder si la sustitución fue exitosa
                isPolynomialHandled = true;

                // Expandir si es necesario (ej: (x+h)^2)
                let fxPlusHExpandedNode = fxPlusHNode.expand();

                // Paso 2: Encontrar f(x + h)
                let explanation_fxPlusH = `En esta función, sustituimos $x$ por $(x + h)$ donde sea que aparezca $x$.`;
                
                // Explicaciones más específicas para tipos comunes
                if (funcString.includes('x^2')) {
                    explanation_fxPlusH += `\n\nSi $f(x)$ incluye $x^2$, entonces $x^2$ se convierte en $(x+h)^2 = x^2 + 2xh + h^2$.`;
                }
                if (funcString.includes('x') && !funcString.includes('x^2') && !funcString.includes('x^3')) {
                    explanation_fxPlusH += `\n\nSi $f(x)$ incluye un término lineal como $ax$, se convierte en $a(x+h) = ax + ah$.`;
                }
                if (funcString.match(/\d+$/) && !funcString.includes('x')) { // Es una constante
                    explanation_fxPlusH += `\n\nSi $f(x)$ es una constante, $f(x+h)$ es la misma constante ya que no depende de $x$.`;
                }

                stepsHtml += `
                    <div class="step">
                        <h3>Paso 2: Encontrar $f(x + h)$</h3>
                        <p>${explanation_fxPlusH}</p>
                        <div class="math-formula">
                            $$f(x + h) = ${fxPlusHExpandedNode.toTex()}$$
                        </div>
                        <p>Esta es la función evaluada en un punto ligeramente desplazado de $x$.</p>
                    </div>
                `;

                // Paso 3: Sustituir en la fórmula del límite
                let numeratorInitialNode = math.subtract(fxPlusHExpandedNode, node);
                
                stepsHtml += `
                    <div class="step">
                        <h3>Paso 3: Sustituir $f(x + h)$ y $f(x)$ en la fórmula del límite</h3>
                        <p>Ahora colocamos nuestras expresiones en la fórmula de la definición de la derivada:</p>
                        <div class="math-formula">
                            $$f'(x) = \\lim_{h \\to 0} \\frac{(${fxPlusHExpandedNode.toTex()}) - (${node.toTex()})}{h}$$
                        </div>
                        <p>Esta expresión representa la tasa de cambio promedio de la función entre $x$ y $x+h$.</p>
                    </div>
                `;

                // Paso 4: Simplificar el numerador
                let numeratorSimplifiedNode = numeratorInitialNode.simplify(); // Simplificar combinando términos
                
                stepsHtml += `
                    <div class="step">
                        <h3>Paso 4: Simplificar el numerador</h3>
                        <p>Expandimos y eliminamos los paréntesis en el numerador. Es crucial que los términos que no contienen $h$ se cancelen entre sí.</p>
                        <div class="math-formula">
                            $$f'(x) = \\lim_{h \\to 0} \\frac{${numeratorSimplifiedNode.toTex()}}{h}$$
                        </div>
                        <p>Si algún término sin $h$ no se cancela, probablemente haya un error en la expansión.</p>
                    </div>
                `;

                // Paso 5: Factorizar h en el numerador
                // Esta es la parte más difícil de hacer genérica con math.js sin un CAS completo.
                // Lo haremos asumiendo que después de la simplificación, 'h' es un factor común.
                let numeratorFactoredTex = '';
                try {
                    // Convertir el nodo simplificado a una cadena para intentar una factorización manual.
                    // Esto es una simplificación y podría no funcionar para todos los casos.
                    const simplifiedString = numeratorSimplifiedNode.toString();
                    if (simplifiedString.includes('h')) {
                        // Intenta parsear para factorizar h, o al menos mostrar que h es común
                        // Esto es rudimentario, una mejor solución necesita lógica de factorización.
                        const tempNode = math.parse(simplifiedString);
                        // Esto es un parche. math.js no tiene un método .factor(variable) directo para extractos.
                        // Lo que podemos hacer es asegurar que todos los términos son divisibles por 'h'
                        // y mostrar el resultado de la división.
                        let terms = simplifiedString.split(/[+-]/).map(term => term.trim()).filter(term => term !== '');
                        let commonHTerms = [];
                        terms.forEach(term => {
                            if (term.includes('h')) {
                                commonHTerms.push(term);
                            }
                        });

                        if (commonHTerms.length > 0) {
                            // Construir la expresión dividida por h
                            let dividedByHNode = math.simplify(math.divide(numeratorSimplifiedNode, math.parse('h')));
                            numeratorFactoredTex = `h \\left( ${dividedByHNode.toTex()} \\right)`;
                        } else {
                            numeratorFactoredTex = numeratorSimplifiedNode.toTex(); // No se puede factorizar h
                        }

                    } else {
                        numeratorFactoredTex = numeratorSimplifiedNode.toTex(); // No hay 'h' para factorizar (ej: constante)
                    }

                } catch (e) {
                    // Fallback si la factorización es demasiado compleja
                    numeratorFactoredTex = numeratorSimplifiedNode.toTex();
                }

                stepsHtml += `
                    <div class="step">
                        <h3>Paso 5: Factorizar $h$ en el numerador</h3>
                        <p>Factorizamos $h$ de todos los términos del numerador. Esto nos permitirá eliminar la indeterminación $\\frac{0}{0}$ cuando $h \\to 0$.</p>
                        <div class="math-formula">
                            $$f'(x) = \\lim_{h \\to 0} \\frac{${numeratorFactoredTex}}{h}$$
                        </div>
                    </div>
                `;

                // Paso 6: Cancelar h
                let afterCancellationNode;
                try {
                     afterCancellationNode = math.simplify(math.divide(numeratorSimplifiedNode, math.parse('h')));
                } catch (e) {
                     afterCancellationNode = numeratorSimplifiedNode; // Fallback
                }


                stepsHtml += `
                    <div class="step">
                        <h3>Paso 6: Cancelar $h$</h3>
                        <p>Dado que $h$ tiende a cero pero no es exactamente cero, podemos cancelar el término $h$ del numerador y del denominador:</p>
                        <div class="math-formula">
                            $$f'(x) = \\lim_{h \\to 0} ${afterCancellationNode.toTex()}$$
                        </div>
                        <p>Este paso elimina la forma indeterminada y nos permite evaluar el límite.</p>
                    </div>
                `;

                // Paso 7: Evaluar el límite
                let finalResultStepNode;
                try {
                     finalResultStepNode = afterCancellationNode.evaluate({h:0});
                } catch (e) {
                     finalResultStepNode = derivativeNode; // Fallback to final derivative if evaluation fails
                }
                
                stepsHtml += `
                    <div class="step">
                        <h3>Paso 7: Evaluar el límite</h3>
                        <p>Finalmente, sustituimos $h = 0$ en la expresión restante para encontrar la derivada:</p>
                        <div class="math-formula">
                            $$f'(x) = ${finalResultStepNode.toTex()}$$
                        </div>
                        <p>¡Y este es el resultado final de la derivada por el proceso largo!</p>
                    </div>
                `;

            } else { // Si no es un polinomio simple o la sustitución falló
                 isPolynomialHandled = false;
            }
        }


        if (!isPolynomialHandled) {
            stepsHtml += `
                <div class="info-message">
                    <p>Para funciones más complejas, la generación de los pasos intermedios de forma automática y simbólica (expansión de $(x+h)^n$, simplificación de términos) es un proceso muy complejo que requiere un sistema de álgebra computacional completo.</p>
                    <p>Sin embargo, la derivada final de $f(x) = ${node.toTex()}$ es:</p>
                    <div class="math-formula">
                        $$f'(x) = ${finalDerivativeTex}$$
                    </div>
                    <p>¡Puedes intentar verificar esto con las reglas de derivación!</p>
                </div>
            `;
        }

        outputDiv.innerHTML = stepsHtml;

        // Renderizar las ecuaciones MathJax después de que el HTML esté en el DOM
        MathJax.typesetPromise().then(() => {
            // console.log("MathJax typeset complete.");
        }).catch((err) => console.error("MathJax typesetting failed: " + err.message));

    } catch (error) {
        outputDiv.innerHTML = `<p class="error-message">Error al procesar la función. Asegúrate de usar un formato válido (ej: x^2 + 3*x, sin(x)). Detalle: ${error.message}</p>`;
        console.error("Error calculating derivative:", error);
    }
}

// Calcular la derivada inicial al cargar la página (con el valor predeterminado)
document.addEventListener('DOMContentLoaded', calculateDerivative);
